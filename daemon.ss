(require errortrace)
(load "lib.ss")

(define (read-maybe port)
  (let* ((bstr (make-bytes 100))
         (n (read-bytes-avail!* bstr port)))
    (if (> n 0)
      (bytes->string/utf-8 bstr #f 0 (- n 1))
      #f)))

(define (check-ctrl port)
  (let ((a (read-maybe port)))
    (mtch a
      #f '()
      e (let ((e (read (open-input-string e))))
          ;(shew 'eval e)
          (display "\n")
          (execute e)))))

(define (show-exn exn)
  (shew exn)
  (print-error-trace (current-output-port) exn))

(define (safe-run thunk)
  (with-handlers
    ([(lambda (exn) #t) (lambda (exn) (show-exn exn))])
    (thunk)))

(define (execute e)
  (safe-run (lambda () (eval e))))

(define dloaded-files (make-hash))
(define (dload filename)
  (let ((now (current-seconds))
        (mtime (file-or-directory-modify-seconds filename)))
    (if (or (not (hash-has-key? dloaded-files filename))
            (> mtime (hash-ref dloaded-files filename)))
      (begin
        (hash-set! dloaded-files filename now)
        (shew `(loading ,filename))
        (safe-run (lambda () (load filename))))
      ;(shew 'already filename)
      '())))

(define (daemon)
  (letrec ((loop (lambda ()
    (let ((ss (tcp-listen 5001 4 #t)))
      ;(shew 'Listening)
      (let-values (((bin bout) (tcp-accept ss)))
        ;(shew 'Connected)
        (let ((input (read-objects-port bin)))
          ;(shew 'read input)
          (let ((all `(begin . ,input)))
            (parameterize ((current-output-port bout))
              (let ((result (execute all)))
                (if (not (void? result))
                  (display result)
                  '())))
            (close-output-port bout)
            (tcp-close ss)
            (loop))))))))
    (loop)))
