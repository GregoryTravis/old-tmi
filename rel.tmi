deref rec k = let find-it (Cons (Entry kk vv) d) = if k == kk then vv else find-it d
                  find-it Nil = assert Nil [False]
               in find-it (rec-to-entries rec)

member a (Cons aa d) = if a == aa then True else (member a d)
member a Nil = False

list-append (Cons a d) lyst = (Cons a (list-append d lyst))
list-append Nil lyst = lyst

not True = False
not False = True

and True True = True
and True False = False
and False True = False
and False False = False

filter (Cons a d) f = if (f a) then (Cons a (filter d f)) else (filter d f)
filter Nil f = Nil

unique? (Cons a d) = and (not (member a d)) (unique? d)
unique? Nil = True

;; Does not check if a or b is non-unique.
list-intersect? a b = not (unique? (list-append a b))

keys rec = map (/. ((Entry k v)) k) (rec-to-entries rec)

add-recs a b = if (not (list-intersect? (keys a) (keys b)))
               then (entries-to-rec (list-append (rec-to-entries a) (rec-to-entries b)))
               else (err (RecOverlap a b))

wherre rel f = filter rel f

proj rel fields = map (/. (rec) proj-rec rec fields) rel
proj-rec rec fields = entries-to-rec
  (filter (/. ((Entry k v)) member k fields) (rec-to-entries rec))

rmkey rec k = if (member k (keys rec)) then (entries-to-rec (rmkey-1 (rec-to-entries rec) k)) else (err (NoSuchKey k rec))
rmkey-1 (Cons (Entry k v) d) kk = if k == kk then d else (Cons (Entry k v) (rmkey-1 d kk))
rmkey-1 Nil kk = err (Ummmmm)

mkrec kvs = entries-to-rec (map list-to-entry kvs)
list-to-entry (Cons k (Cons v Nil)) = (Entry k v)

un-deref rec k v = add-recs (rmkey rec k) (mkrec [[k, v]])

pnot p = /. (x) (not (p x))

un-where rel f w = let yes = wherre rel f
                       no = wherre rel (pnot f)
                    in (list-append no w)

one (Cons a Nil) = a
un-one lyst x = [x]
