deref-e (Cons (Entry k v) d) kk = if k == kk then v else deref-e d kk
deref-e Nil kk = assert Nil [False]
deref rec k = deref-e (rec-to-entries rec) k

member a (Cons aa d) = if a == aa then True else (member a d)
member a Nil = False

list-append (Cons a d) lyst = (Cons a (list-append d lyst))
list-append Nil lyst = lyst

not True = False
not False = True

and True True = True
and True False = False
and False True = False
and False False = False

filter (Cons a d) f = if (f a) then (Cons a (filter d f)) else (filter d f)
filter Nil f = Nil

unique? (Cons a d) = and (not (member a d)) (unique? d)
unique? Nil = True

;; Does not check if a or b is non-unique.
list-intersect? a b = not (unique? (list-append a b))

key-of-entry (Entry k v) = k
keys rec = map key-of-entry (rec-to-entries rec)

add-recs a b = if (not (list-intersect? (keys a) (keys b))) then (add-recs-1 (rec-to-entries a) (rec-to-entries b)) else (err (RecOverlap a b))
add-recs-1 es0 es1 = entries-to-rec (list-append es0 es1)

wherre rel f = filter rel f

proj rel fields = map (/. (rec) proj-rec rec fields) rel
proj-rec rec fields = entries-to-rec (filter (/. (e) entry-key-in-keys e fields) (rec-to-entries rec))

entry-key-in-keys (Entry k v) keys = member k keys

rmkey rec k = if (member k (keys rec)) then (entries-to-rec (rmkey-1 (rec-to-entries rec) k)) else (err (NoSuchKey k rec))
rmkey-1 (Cons (Entry k v) d) kk = if k == kk then d else (Cons (Entry k v) (rmkey-1 d kk))
rmkey-1 Nil kk = err (Ummmmm)

mkrec kvs = entries-to-rec (map list-to-entry kvs)
list-to-entry (Cons k (Cons v Nil)) = (Entry k v)

un-deref rec k v = add-recs (rmkey rec k) (mkrec [[k, v]])

pnot p = /. (x) (not (p x))

un-where rel f w = let yes = wherre rel f
                       no = wherre rel (pnot f)
                    in (list-append no w)
