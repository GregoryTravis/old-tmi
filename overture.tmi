;; TMI oerture

tmi-foldr f z [] = z
tmi-foldr f z (Cons x xs) = f x (tmi-foldr f z xs)
tmi-foldl f z [] = z
tmi-foldl f z (Cons x xs) = tmi-foldl f (f z x) xs

fact 0 = 1
fact n = n * fact (n - 1)

map f [] = []
map f (Cons a d) = Cons (f a) (map f d)

nth 0 (Cons a d) = a
nth n (Cons a d) = nth (n - 1) d

insertion-sort [] = []
insertion-sort (Cons a d) = insert-into a (insertion-sort d)
insert-into x [] = [x]
insert-into x (Cons a d) = if x < a then Cons x (Cons a d) else Cons a (insert-into x d)

filter p [] = []
filter p (Cons a d) = if p a then Cons a (filter p d) else filter p d

(int a) + (int b) = native+ a b
(int a) - (int b) = native- a b
(int a) * (int b) = native* a b
(int a) / (int b) = native/ a b

a == b = native== a b
a != b = native!= a b
(int a) < (int b) = native< a b
(int a) > (int b) = native> a b
(int a) <= (int b) = native<= a b
(int a) >= (int b) = native>= a b

(string a) + (string b) = string-append a b

all (Cons True d) = all d
all [] = True
all x = False

test expected actual = if expected == actual then True else (err (TestFailure expected actual))
;; TODO get rid of test-rel
test-rel expected actual = if rel-equal? expected actual then True else err (TestFailure expected actual)
assert v checks = if (all checks) then v else (err (AssertionFailure v checks))

read-all-chars port = do c <- Command ["read-char", port]
                         is-eof <- Command ["eof-object?", c]
                         if is-eof then (Return []) else do tail <- read-all-chars port 
                                                            Return (Cons c tail)

read-file filename = do port <- Command ["open-input-file", filename]
                        chars <- read-all-chars port
                        s <- Command ["list->string", chars]
                        [] <- Command ["close-input-port", port]
                        Return s

read-data filename = Command ["native-read-data", filename]
write-data filename o = Command ["native-write-data", filename, o]

tshew o = ffi display-newline (tmi-pretty-print o)

;; TODO I use these filename params because 'in' and 'of' can't start an
;; identifier yet
transform-file f rfile wfile = do
  d <- read-data rfile
  write-data wfile (f d)

first-maybe f (Cons a d) = case (f a) of (Just x) => (Just x)
                                         Nothing => first-maybe f d
first-maybe f [] = Nothing

maybe-default (Just x) def = x
maybe-default Nothing def = def

member a (Cons aa d) = if a == aa then True else (member a d)
member a [] = False

list-append (Cons a d) lyst = (Cons a (list-append d lyst))
list-append [] lyst = lyst

not True = False
not False = True

and True True = True
and True False = False
and False True = False
and False False = False

filter (Cons a d) f = if (f a) then (Cons a (filter d f)) else (filter d f)
filter [] f = []

unique? (Cons a d) = and (not (member a d)) (unique? d)
unique? [] = True

;; Does not check if a or b is non-unique.
list-intersect? a b = not (unique? (list-append a b))
