;; TMI oerture

fact 0 = 1
fact n = n * fact (n - 1)

map f Nil = Nil
map f (Cons a d) = Cons (f a) (map f d)

nth 0 (Cons a d) = a
nth n (Cons a d) = nth (n - 1) d

insertion-sort Nil = Nil
insertion-sort (Cons a d) = insert-into a (insertion-sort d)
insert-into x Nil = [x]
insert-into x (Cons a d) = if (x < a) then (Cons x (Cons a d)) else (Cons a (insert-into x d))

filter p Nil = Nil
filter p (Cons a d) = if (p a) then (Cons a (filter p d)) else (filter p d)

(int a) + (int b) = native-+ a b
(string a) + (string b) = string-append a b

all (Cons True d) = all d
all Nil = True
all x = False

test expected actual = if expected == actual then True else (err (TestFailure expected actual))
;; TODO get rid of test-rel
test-rel expected actual = if (rel-equal? expected actual) then True else (err (TestFailure expected actual))
assert v checks = if (all checks) then v else (err (AssertionFailure v checks))

read-all-chars port = do c <- Command ["read-char", port]
                         is-eof <- Command ["eof-object?", c]
                         if is-eof then (Return Nil) else do tail <- read-all-chars port 
                                                             Return (Cons c tail)

read-file filename = do port <- Command ["open-input-file", filename]
                        chars <- read-all-chars port
                        s <- Command ["list->string", chars]
                        vd <- Command ["close-input-port", port]
                        Return s

read-data filename = Command ["native-read-data", filename]
write-data filename o = Command ["native-write-data", filename, o]

tshew o = Command ["display-newline", (tmi-pretty-print o)]

;; TODO I use these filename params because 'in' and 'of' can't start an
;; identifier yet
transform-file f rfile wfile = do
  d <- read-data rfile
  write-data wfile (f d)
