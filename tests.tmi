double x = x * 2
foo (Bar a) = a
wut a = /. (b) a + b

t00 = test [2, 4, 6] (map double [1, 2, 3])
t01 = test 3628800 (fact 10)
t02 = test 45 (foo (Bar 45))
t03 = test (foo (Bar (Both 43 44))) (Both 43 44)
t04 = test [8, 10, 12] (map (/. (x) x * 2) [4, 5, 6])
t05 = test 21 ((wut 1) 20)
t06 = test 120 ((/. (a b) a * b) 10 12)
t07 = test [104, 105, 106, 107] (map (wut 100) [4, 5, 6, 7])
t08 = test [1, 2, 3, 4, 5] (insertion-sort [3, 4, 1, 2, 5])
t09 = test [1, 1, 1] (filter (/. (n) n == 1) [1, 2, 1, 2, 1, 2])
t10 = test 1 1

;; Layout tests
foo0 a = let b = a + a in b * b
foo1 a = let b = a + a
         in b * b
foo2 a = let
           b = a + a
         in b * b
foo3 a = let b =
               a + a
         in b * b
foo4 a = let b =
              a + a
         in b * b
foo5 a = let b =
              a + a
         in
          b * b
t11 = test [36, 36, 36, 36, 36, 36] [foo0 3, foo1 3, foo2 3, foo3 3, foo4 3, foo5 3]

t12 = a * a + a where a = 2
;; Layout tests
t13 = a * b + c where a = 2
                      b = 10
                      c = 7
t14 = a * b + c where
                 a = 2
                 b = 10
                 c = 7
t15 = a * b + c
       where
        a = 2
        b = 10
        c = 7
t16 = a * b + c
       where a = 2
             b = 10
             c = 7
t17 = test [6, 27, 27, 27, 27] [t12, t13, t14, t15, t16]

t18 a = case a of (Boo a) => a + 100
                  (Foo b) => b + 1000
t19 a = case a of
          (Boo a) => a + 100
          (Foo b) => b + 1000
t20 = let roo (Boo a) = a + 100
          roo (Foo b) = b + 1000
       in
          roo
t20 = test [[103, 1004], [103, 1004], [103, 1004]] [[t18 (Boo 3), t18 (Foo 4)], [t19 (Boo 3), t19 (Foo 4)], [t20 (Boo 3), t20 (Foo 4)]]

t21 = test 10 (nth 0 [10, 20, 30])
t22 = test 20 (nth 1 [10, 20, 30])
t23 = test 30 (nth 2 [10, 20, 30])

;; Naked constructors
id x = x
dub x = [x, x]
t24 = test Nil (nth 0 (dub Nil))
t25 = test Nil (nth 1 (dub Nil))
t26 x = case x of (Nil a b) => a + b
t27 = test 3 (t26 (Nil 1 2))

;; Commands and do
t28 = do port <- Command ["open-input-string", "abc"]
         chars <- read-all-chars port
         s <- Command ["list->string", chars]
         Return 1 ;; (test "abc" s)

t29 = do s <- read-file "test-files/read-test-file"
         Return (test "asdf" s)

t30 = test [3, "asdfzxcv"] [1 + 2, "asdf" + "zxcv"]

;; Just for parsing
t31 = Return { a: { c: let r = 5 in r + r }, b: 13 }

;; Fragile
t32 = test "{b: 13, a: {c: 10}}" (tmi-pretty-print { a: { c: let r = 5 in r + r }, b: 13 })
t33 = test "[4, 5]" (tmi-pretty-print [4, 5])

t34 = do s <- read-data "test-files/read-data-test-file"
         Return (test [{a: {c: 10}, b: 13}, {h: 56}] s)

t35 = test True (all [True])
t36 = test True (all [True, True])
;; t37 = test True (all Nil))
t38 = test False (all [False])
t39 = test False (all [False, True])

t40 = test 31 (assert 31 [True])

t41 = test {a: 10, b: 20} (entries-to-rec (rec-to-entries {a: 10, b: 20}))
t42 = test 10 (deref {a: 10, b: 20} "a")
t44 = test 20 (deref {a: 10, b: 20} "b")

run-do-tests = do vd <- t28
                  vd <- t29
                  vd <- t34
                  Return "OK"

main = do ok <- run-do-tests
          Return "OK"
