double x = x * 2
foo (Bar a) = a
wut a = /. (b) a + b

t00 = test [2, 4, 6] (map double [1, 2, 3])
t01 = test 3628800 (fact 10)
t02 = test 45 (foo (Bar 45))
t03 = test (foo (Bar (Both 43 44))) (Both 43 44)
t04 = test [8, 10, 12] (map (/. (x) x * 2) [4, 5, 6])
t05 = test 21 ((wut 1) 20)
t06 = test 120 ((/. (a b) a * b) 10 12)
t07 = test [104, 105, 106, 107] (map (wut 100) [4, 5, 6, 7])
t08 = test [1, 2, 3, 4, 5] (insertion-sort [3, 4, 1, 2, 5])
t09 = test [1, 1, 1] (filter (/. (n) n == 1) [1, 2, 1, 2, 1, 2])
t10 = test 1 1

;; Layout tests
foo0 a = let b = a + a in b * b
foo1 a = let b = a + a
         in b * b
foo2 a = let
           b = a + a
         in b * b
foo3 a = let b =
               a + a
         in b * b
foo4 a = let b =
              a + a
         in b * b
foo5 a = let b =
              a + a
         in
          b * b
t11 = test [36, 36, 36, 36, 36, 36] [foo0 3, foo1 3, foo2 3, foo3 3, foo4 3, foo5 3]

t12 = a * a + a where a = 2
;; Layout tests
t13 = a * b + c where a = 2
                      b = 10
                      c = 7
t14 = a * b + c where
                 a = 2
                 b = 10
                 c = 7
t15 = a * b + c
       where
        a = 2
        b = 10
        c = 7
t16 = a * b + c
       where a = 2
             b = 10
             c = 7
t17 = test [6, 27, 27, 27, 27] [t12, t13, t14, t15, t16]

t18 a = case a of (Boo a) => a + 100
                  (Foo b) => b + 1000
t19 a = case a of
          (Boo a) => a + 100
          (Foo b) => b + 1000
t20 = let roo (Boo a) = a + 100
          roo (Foo b) = b + 1000
       in
          roo
t20 = test [[103, 1004], [103, 1004], [103, 1004]] [[t18 (Boo 3), t18 (Foo 4)], [t19 (Boo 3), t19 (Foo 4)], [t20 (Boo 3), t20 (Foo 4)]]

t21 = test 10 (nth 0 [10, 20, 30])
t22 = test 20 (nth 1 [10, 20, 30])
t23 = test 30 (nth 2 [10, 20, 30])

;; Naked constructors
id x = x
dub x = [x, x]
t24 = test Nil (nth 0 (dub Nil))
t25 = test Nil (nth 1 (dub Nil))
t26 x = case x of (Nil a b) => a + b
t27 = test 3 (t26 (Nil 1 2))

;; Commands and do
t28 = do port <- Command ["open-input-string", "abc"]
         chars <- read-all-chars port
         s <- Command ["list->string", chars]
         Return 1 ;; (test "abc" s)

t29 = do s <- read-file "test-files/read-test-file"
         Return (test "asdf" s)

run-do-tests = do vd <- t28
                  vd <- t29
                  Return "OK"

main = do ok <- run-do-tests
          Command ["shew", ok]
